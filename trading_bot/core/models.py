from datetime import datetime
from typing import Optional, Literal

from pydantic import BaseModel, Field

class Ohlcv(BaseModel):
    """
    Represents a single OHLCV candle.
    """
    timestamp: datetime = Field(..., description="The start time of the candle.")
    open: float = Field(..., description="Opening price.")
    high: float = Field(..., description="Highest price.")
    low: float = Field(..., description="Lowest price.")
    close: float = Field(..., description="Closing price.")
    volume: Optional[float] = Field(None, description="Trading volume.")

class Signal(BaseModel):
    """
    Represents a trading signal generated by the strategy.
    """
    instrument: str = Field(..., description="The trading instrument ticker.")
    timestamp: datetime = Field(..., description="The timestamp of the signal generation.")
    pattern_name: str = Field(..., description="The name of the pattern that generated the signal.")
    signal_type: Literal['entry', 'exit'] = Field(..., description="Type of signal.")
    direction: Literal['long', 'short'] = Field(..., description="Signal direction.")
    confluence_score: float = Field(..., ge=0, le=100, description="A score (0-100) representing the quality of the signal based on various factors.")
    target_price: Optional[float] = Field(None, description="Optional target price for the trade.")
    stop_loss: Optional[float] = Field(None, description="The price at which to place the stop-loss.")
    candle: Ohlcv = Field(..., description="The candle that generated the signal.")

class Trade(BaseModel):
    """
    Represents an executed trade, from entry to exit.
    """
    trade_id: str = Field(..., description="Unique identifier for the trade.")
    instrument: str = Field(..., description="The trading instrument.")
    direction: Literal['long', 'short'] = Field(..., description="Direction of the trade.")
    entry_timestamp: datetime = Field(..., description="Timestamp of the trade entry.")
    entry_price: float = Field(..., description="Price at which the trade was entered.")
    entry_fee: float = Field(0.0, description="Fees associated with entering the trade.")
    size: float = Field(..., description="The quantity of the instrument traded.")
    status: Literal['open', 'closed'] = Field('open', description="Current status of the trade.")

    exit_timestamp: Optional[datetime] = Field(None, description="Timestamp of the trade exit.")
    exit_price: Optional[float] = Field(None, description="Price at which the trade was exited.")
    exit_fee: float = Field(0.0, description="Fees associated with exiting the trade.")

    pnl: Optional[float] = Field(None, description="Profit and Loss for the trade.")

    def close_trade(self, timestamp: datetime, price: float, fee: float = 0.0):
        self.exit_timestamp = timestamp
        self.exit_price = price
        self.exit_fee = fee
        self.status = 'closed'

        direction_multiplier = 1 if self.direction == 'long' else -1
        price_change = self.exit_price - self.entry_price
        self.pnl = (price_change * self.size * direction_multiplier) - self.entry_fee - self.exit_fee

class Position(BaseModel):
    """
    Represents a current holding of an instrument.
    Can be an aggregation of multiple trades.
    """
    instrument: str = Field(..., description="The trading instrument.")
    direction: Literal['long', 'short'] = Field(..., description="Net position direction.")
    size: float = Field(..., gt=0, description="Total size of the position.")
    average_entry_price: float = Field(..., description="The weighted average entry price for the position.")

    # This would be updated by a market data feed in a live system
    unrealized_pnl: float = Field(0.0, description="Current unrealized profit or loss based on mark-to-market price.")

    def update_pnl(self, current_price: float):
        direction_multiplier = 1 if self.direction == 'long' else -1
        price_change = current_price - self.average_entry_price
        self.unrealized_pnl = price_change * self.size * direction_multiplier
